# Copyright 2005-2016 ECMWF.
#
# This software is licensed under the terms of the Apache Licence Version 2.0
# which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#
# In applying this licence, ECMWF does not waive the privileges and immunities granted to it by
# virtue of its status as an intergovernmental organisation nor does it submit to any jurisdiction.
#
# START grib1::section
# SECTION 4, Binary data section
#  Length of section
# (octets)
position offsetSection4;

# Due to a trick done by GRIBEX to support large GRIBs, we need a special treatment
# of the message length and of the section4 lenth, so instead of
# length[3] section4Length                     ;
# we get:
g1_section4_length[3] section4Length(totalLength);

meta section4Pointer section_pointer(offsetSection4,section4Length,4);

g1_half_byte_codeflag halfByte;
flags[1] dataFlag "grib1/11.table" = 0 : read_only;
signed[2] binaryScaleFactor = 0 : read_only,dump;
ibmfloat referenceValue : read_only,dump;
unsigned[1] bitsPerValue : dump ;
alias numberOfBitsContainingEachPackedValue = bitsPerValue;

meta referenceValueError reference_value_error(referenceValue,ibm);

flagbit sphericalHarmonics(dataFlag,7) : dump;
flagbit complexPacking(dataFlag,6) : dump;
flagbit integerPointValues(dataFlag,5) : dump;
flagbit additionalFlagPresent(dataFlag,4) : edition_specific,dump;

transient hideThis=0;

concept packingType {
#set uses the last one
#get returns the first match
  "grid_simple"                       = { sphericalHarmonics = 0; complexPacking = 0; additionalFlagPresent = 0;}
  "grid_ieee"                         = { sphericalHarmonics = 0; complexPacking = 0;
                                          integerPointValues=1; additionalFlagPresent=1;}
  "spectral_complex"                  = { sphericalHarmonics = 1; complexPacking = 1;
											additionalFlagPresent = 0; }
  "spectral_simple"                   = { sphericalHarmonics = 1; complexPacking = 0; additionalFlagPresent = 0;
                                          representationMode=1;}
  "spectral_ieee"                  = { sphericalHarmonics = 1; complexPacking = 1;
											additionalFlagPresent = 0; hideThis=1; }
  "grid_simple_matrix"                = { sphericalHarmonics = 0; complexPacking = 0; additionalFlagPresent = 1;}
  "grid_second_order"                 = { sphericalHarmonics = 0; complexPacking = 1; }
  "grid_complex"                      = { sphericalHarmonics = 0; complexPacking = 0; additionalFlagPresent = 0;}
  "grid_complex_spatial_differencing" = { sphericalHarmonics = 0; complexPacking = 0; additionalFlagPresent = 0;}
  "grid_jpeg"                         = { sphericalHarmonics = 0; complexPacking = 0; additionalFlagPresent = 0;}
  "grid_png"                          = { sphericalHarmonics = 0; complexPacking = 0; additionalFlagPresent = 0;}
  "grid_simple_log_preprocessing"= { sphericalHarmonics = 0; complexPacking = 0; additionalFlagPresent = 0;}
} : dump;


alias ls.packingType=packingType;
alias typeOfPacking=packingType;

if( binaryScaleFactor == -32767) {
  constant dataRepresentationTemplateNumber = 0;
  constant bitMapIndicator = 0;
  # For grib 1 -> 2
  position offsetBeforeData;
  transient numberOfCodedValues=numberOfPoints;
  meta values data_dummy_field(
        section4Length,
        offsetBeforeData,
        offsetSection4,
        unitsFactor,
        unitsBias,
        changingPrecision,
        numberOfCodedValues,
        bitsPerValue,
        referenceValue,
        binaryScaleFactor,
        decimalScaleFactor,
        halfByte,
		packingType,
		grid_ieee,precision,
        missingValue,
        numberOfPoints,
        bitmap
      ) : dump;
} else {
  template dataValues "grib1/data.[packingType:s].def";
}

position offsetAfterData;

transient dataLength=(offsetAfterData-offsetBeforeData)/8;

if (bitmapPresent==1) {
  alias numberOfEffectiveValues=numberOfDataPoints;
} else {
  alias numberOfEffectiveValues=numberOfCodedValues;
}

_if (sphericalHarmonics) {
	alias numberOfEffectiveValues=numberOfValues;
}

#meta setDecimalPrecision suppressed(decimalPrecision,changeDecimalPrecision);
meta changeDecimalPrecision decimal_precision(bitsPerValue,decimalScaleFactor,changingPrecision,values)  : edition_specific;
meta decimalPrecision decimal_precision(bitsPerValue,decimalScaleFactor,changingPrecision)  : edition_specific;
alias setDecimalPrecision=changeDecimalPrecision;

meta bitsPerValueAndRepack bits_per_value(values,bitsPerValue)  : edition_specific;
alias setBitsPerValue=bitsPerValueAndRepack;

meta scaleValuesBy scale_values(values,missingValue) : edition_specific;
meta offsetValuesBy offset_values(values,missingValue) : edition_specific;

concept gridType {
#set uses the last one
#get returns the first match
  "regular_ll"           = {dataRepresentationType = 0;  sphericalHarmonics = 0; PLPresent=0;}
  "reduced_ll"           = {dataRepresentationType = 0;  sphericalHarmonics = 0; PLPresent=1; Ni=missing(); }
  "mercator"             = {dataRepresentationType = 1;  sphericalHarmonics = 0; PLPresent=0; }
  "lambert"              = {dataRepresentationType = 3;  sphericalHarmonics = 0; PLPresent=0; }
  "polar_stereographic"  = {dataRepresentationType = 5;  sphericalHarmonics = 0; PLPresent=0; }
  "UTM"                  = {dataRepresentationType = 6;  sphericalHarmonics = 0; PLPresent=0; }
  "simple_polyconic"     = {dataRepresentationType = 7;  sphericalHarmonics = 0; PLPresent=0; }
  "albers"               = {dataRepresentationType = 8;  sphericalHarmonics = 0; PLPresent=0; }
  "miller"               = {dataRepresentationType = 8;  sphericalHarmonics = 0; PLPresent=0; }
  "rotated_ll"           = {dataRepresentationType = 10; sphericalHarmonics = 0; PLPresent=0; }
  "stretched_ll"         = {dataRepresentationType = 20; sphericalHarmonics = 0; PLPresent=0; }
  "stretched_rotated_ll" = {dataRepresentationType = 30; sphericalHarmonics = 0; PLPresent=0; }
  "regular_gg"           = {dataRepresentationType = 4;  sphericalHarmonics = 0; PLPresent=0; }
  "rotated_gg"           = {dataRepresentationType = 14; sphericalHarmonics = 0; PLPresent=0; }
  "stretched_gg"         = {dataRepresentationType = 24; sphericalHarmonics = 0; PLPresent=0; }
  "stretched_rotated_gg" = {dataRepresentationType = 34; sphericalHarmonics = 0; PLPresent=0; }
  "reduced_gg"           = {dataRepresentationType = 4;  sphericalHarmonics = 0;
                            PLPresent=1; numberOfPointsAlongAParallel = missing();
                            iDirectionIncrement = missing(); ijDirectionIncrementGiven=0;}
  "sh"                   = {dataRepresentationType = 50; sphericalHarmonics = 1; PLPresent=0; }
  "rotated_sh"           = {dataRepresentationType = 60; sphericalHarmonics = 1; PLPresent=0; }
  "stretched_sh"         = {dataRepresentationType = 70; sphericalHarmonics = 1; PLPresent=0; }
  "stretched_rotated_sh" = {dataRepresentationType = 80; sphericalHarmonics = 1; PLPresent=0; }
  "space_view"           = {dataRepresentationType = 90; sphericalHarmonics = 0; PLPresent=0; }
  "unknown"              = {PLPresent=0;}
  "unknown_PLPresent"    = {PLPresent=1;}
} : dump;

alias ls.gridType=gridType;
alias geography.gridType=gridType;
alias typeOfGrid=gridType;

meta getNumberOfValues size(values) : edition_specific,dump ;

padtoeven padding_sec4_1(offsetSection4,section4Length) ;

meta md5Section4 md5(offsetSection4,section4Length);



